{"version":3,"file":"background.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mBAAmB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA,+BAA+B,kCAAkC;AACjE;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,KAAK,GAAG,MAAM,GAAG,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA,mCAAmC,0BAA0B;AAC7D,iCAAiC,MAAM,QAAQ,iBAAiB;AAChE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,uCAAuC,aAAa;AACpD;AACA;AACA;AACA;AACyB;;;;;;;UC7FzB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;ACNgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,CAAC;AACD;AACA;AACA,+BAA+B,UAAU,eAAe;AACxD,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,QAAQ;AAC/C,SAAS;AACT;AACA;AACA,CAAC;AACD;AACA,6BAA6B,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,EAAE,UAAU,GAAG;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA,4DAA4D;AAC5D;AACA;AACA,wBAAwB,yDAAa;AACrC,qDAAqD,UAAU;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,gBAAgB;AAClE;AACA;AACA,uCAAuC,QAAQ;AAC/C;AACA;AACA,CAAC","sources":["webpack://pixiv-fanbox-downloader/./src/ts/TotalDownload.ts","webpack://pixiv-fanbox-downloader/webpack/bootstrap","webpack://pixiv-fanbox-downloader/webpack/runtime/define property getters","webpack://pixiv-fanbox-downloader/webpack/runtime/hasOwnProperty shorthand","webpack://pixiv-fanbox-downloader/webpack/runtime/make namespace object","webpack://pixiv-fanbox-downloader/./src/ts/background.ts"],"sourcesContent":["class TotalDownload {\n    constructor() {\n        /** 记录每天的下载总体积。key 是当天的 date，value 是当天的下载总量（字节数） */\n        this.data = {};\n        this.init();\n    }\n    init() {\n        // 初始化存储\n        chrome.runtime.onInstalled.addListener((details) => {\n            if (details.reason === 'install') {\n                chrome.storage.local.set({ totalDownload: {} }, () => {\n                    if (chrome.runtime.lastError) {\n                        console.error('初始化存储失败:', chrome.runtime.lastError.message);\n                    }\n                    else {\n                        console.log('totalDownload 初始化成功');\n                    }\n                });\n            }\n        });\n        chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {\n            if (request.msg === 'getTotalDownload') {\n                // 返回今天的数据\n                sendResponse({ total: this.data[this.getDate()] });\n            }\n            else if (request.msg === 'getTotalDownloadHistory30') {\n                // 返回最近 30 天的数据（虽然可以返回所有数据，但是天数太多的话，前台不好展示）\n                this.getLast30DaysData().then((history) => {\n                    sendResponse({ history });\n                });\n                // 由于这个 sendResponse 是异步，所以需要返回 true 让消息端口不要关闭\n                // Return true to keep the message port open for async response\n                return true;\n            }\n            else {\n                // Return false for unhandled messages\n                return false;\n            }\n        });\n        // 加载 totalDownload\n        setTimeout(() => {\n            this.restore();\n        }, 0);\n    }\n    async restore() {\n        const result = await chrome.storage.local.get(['totalDownload']);\n        this.data = result.totalDownload || {};\n    }\n    /** 生成 YYYY-MM-DD 格式的当前日期 */\n    getDate() {\n        const date = new Date();\n        const year = date.getFullYear();\n        const month = (date.getMonth() + 1).toString().padStart(2, '0');\n        const day = date.getDate().toString().padStart(2, '0');\n        return `${year}-${month}-${day}`;\n    }\n    // 添加下载量\n    addDownload(bytes) {\n        const date = this.getDate();\n        this.data[date] = (this.data[date] || 0) + bytes;\n        chrome.storage.local.set({ totalDownload: this.data }, () => {\n            // console.log(`更新 ${date} 的下载量: ${this.data[date]} 字节`)\n        });\n    }\n    /**\n     * 获取最近 30 天的数据（包括今天），以数组形式返回\n     */\n    async getLast30DaysData() {\n        // 如果是空对象，可能尚未从 local storage 里加载数据，尝试重新加载一次\n        // 例如后台脚本被回收了，前台却要查看数据, 于是后台脚本被再次执行，此时可能还是默认值\n        if (Object.keys(this.data).length === 0) {\n            await this.restore();\n        }\n        const today = new Date();\n        const thirtyDaysAgo = new Date(today);\n        thirtyDaysAgo.setDate(today.getDate() - 29);\n        const result = Object.entries(this.data)\n            .filter(([dateStr]) => {\n            // 添加 T00:00:00 使日期初始化为本地时间 0 点\n            // 如果不带 T 部分，JavaScript 会假设时间为 UTC 时间的 00:00:00\n            // 然后，Date 对象会将这个 UTC 时间转换为本地时区（如香港标准时间为 GMT+0800）\n            // 如果带 T，且不带时区标识符（如 Z 或 +08:00）时，JavaScript 会假定它是本地时间\n            // 也就是 GMT+0000\n            // 由于下载器在储存记录时，是使用 new Date() 来获取年月日的，这是本地时间\n            // 所以这里对比时间时，也要初始化为本地时间，即指明 T00:00:00\n            const date = new Date(dateStr + 'T00:00:00');\n            return !isNaN(date.getTime()) && date >= thirtyDaysAgo && date <= today;\n        })\n            .map(([date, bytes]) => ({ date, bytes }));\n        return result;\n    }\n}\nconst totalDownload = new TotalDownload();\nexport { totalDownload };\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { totalDownload } from './TotalDownload';\n// 当点击扩展图标时，显示/隐藏下载面板\nchrome.action.onClicked.addListener(function (tab) {\n    // 在本程序没有权限的页面上点击扩展图标时，url 始终是 undefined，此时不发送消息\n    if (!tab.url) {\n        return;\n    }\n    chrome.tabs.sendMessage(tab.id, {\n        msg: 'click_icon',\n    });\n});\n// 当扩展被安装、被更新、或者浏览器升级时，初始化数据\nchrome.runtime.onInstalled.addListener((details) => {\n    chrome.storage.local.set({ dlData: {}, batchNo: {} });\n});\n/**存储每个下载任务的数据。\n *\n * 因为下载完成的顺序和前台发送的顺序可能不一致，所以需要把数据保存起来以供查询 */\nlet dlData = {};\n/**使用每个页面的 tabId 作为索引，储存当前下载任务的批次编号（在该页面里）。用来判断不同批次的下载 */\nlet batchNo = {};\nconst fileNameList = new Map();\n// 接收下载请求\nchrome.runtime.onMessage.addListener(async function (msg, sender) {\n    // 接收下载任务\n    if (msg.msg === 'send_download') {\n        // 当处于初始状态时，或者变量被回收了，就从存储中读取数据储存在变量中\n        // 之后每当要使用这两个数据时，从变量读取，而不是从存储中获得。这样就解决了数据不同步的问题，而且性能更高\n        if (Object.keys(batchNo).length === 0) {\n            const data = await chrome.storage.local.get(['batchNo', 'dlData']);\n            batchNo = data.batchNo;\n            dlData = data.dlData;\n        }\n        const tabId = sender.tab.id;\n        // 如果开始了新一批的下载，重设批次编号，清空下载索引\n        if (batchNo[tabId] !== msg.taskBatch) {\n            batchNo[tabId] = msg.taskBatch;\n            chrome.storage.local.set({ batchNo });\n        }\n        fileNameList.set(msg.fileUrl, msg.fileName);\n        // 开始下载\n        chrome.downloads.download({\n            url: msg.fileUrl,\n            filename: msg.fileName,\n            conflictAction: 'uniquify',\n            saveAs: false,\n        }, (id) => {\n            // id 是 Chrome 新建立的下载任务的 id\n            dlData[id] = {\n                url: msg.fileUrl,\n                id: msg.id,\n                tabId: tabId,\n                uuid: false,\n                size: -1,\n            };\n            chrome.storage.local.set({ dlData });\n        });\n        return false;\n    }\n});\n// 判断文件名是否变成了 UUID 格式。因为文件名处于整个绝对路径的中间，所以没加首尾标记 ^ $\nconst UUIDRegexp = /[0-9a-z]{8}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{4}-[0-9a-z]{12}/;\n// 监听下载事件\n// 每个下载会触发两次 onChanged 事件\nchrome.downloads.onChanged.addListener(async function (detail) {\n    var _a, _b, _c;\n    // 根据 detail.id 取出保存的数据\n    // 如果有数据，就是本扩展建立的下载，所以不会监听到非本扩展建立的下载\n    let data = dlData[detail.id];\n    if (!data) {\n        const getData = await chrome.storage.local.get(['dlData']);\n        dlData = getData.dlData;\n        data = dlData[detail.id];\n    }\n    if (data) {\n        let msg = '';\n        let err = '';\n        // 判断当前文件名是否正常。下载时必定会有一次 detail.filename.current 有值\n        if (detail.filename && detail.filename.current) {\n            const changedName = detail.filename.current;\n            // 文件名是 UUID\n            if (changedName.match(UUIDRegexp) !== null) {\n                data.uuid = true;\n            }\n            if (changedName.endsWith('jfif')) {\n                data.uuid = true;\n            }\n            // 检查文件名是 URL 里最后一段的情况\n            // Fanbox 下载器的多数文件是直接把原 URL 发送给浏览器下载的，因此很多时候即使受到其他扩展程序的影响，也不会是 UUID，而是原文件名，例如：\n            // https://pixiv.pximg.net/c/1200x630_90_a2_g5/fanbox/public/images/post/10264356/cover/cvfFotXy5Cbc2I0uakDXHG0s.jpeg\n            // 受到影响时，上面的图片保存后是原文件名：\n            // cvfFotXy5Cbc2I0uakDXHG0s.jpeg\n            // 此时的 detail 示例：\n            // const detailExample = {\n            //   \"filename\": {\n            //      current 在 windows 上可能是这样的：\n            //     \"current\": \"C:\\\\download\\\\cvfFotXy5Cbc2I0uakDXHG0s (6).jpeg\",\n            //      current 在 Linux 上可能是这样的：\n            //     \"current\": \"/home/username/Downloads/cvfFotXy5Cbc2I0uakDXHG0s (6).jpeg\",\n            //     \"previous\": \"\"\n            //   },\n            //   \"id\": 1347\n            // }\n            // fileNameList 里储存的预期的文件名示例：\n            // fanbox/omutatsu／おむたつ/2025-07-22-🔞7月22日🔞/0.jpeg\n            const expectedName = fileNameList.get(data.url);\n            if (expectedName) {\n                // 取出预期的文件名的最后一部分，上面的文件名的结果是 \"0\"\n                const name = ((_a = expectedName.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || '';\n                // 取出实际的文件名的最后一部分（注意，即使是与预期一致的文件名，实际上也可能有序号）\n                let name2 = '';\n                if (changedName.includes('\\\\')) {\n                    name2 = ((_b = changedName.split('\\\\').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || '';\n                }\n                else {\n                    name2 = ((_c = changedName.split('/').pop()) === null || _c === void 0 ? void 0 : _c.split('.')[0]) || '';\n                }\n                // 如果实际文件名不是以预期的文件名开头，则说明文件名异常\n                if (name2 && name2.startsWith(name) === false) {\n                    data.uuid = true;\n                }\n            }\n        }\n        if (detail.state && detail.state.current === 'complete') {\n            msg = 'downloaded';\n            // 下载完成后，查询下载项的体积\n            // 查询花费的时间：在下载记录不是很多的情况下，查询耗时多为 2 - 5 ms\n            chrome.downloads.search({ id: detail.id }, (results) => {\n                if (results && results.length > 0) {\n                    const downloadItem = results[0];\n                    const fileSize = downloadItem.fileSize; // 文件大小（字节）\n                    if (fileSize !== -1) {\n                        data.size = fileSize;\n                        totalDownload.addDownload(fileSize);\n                        // console.log(`文件下载完成，大小: ${fileSize} 字节`)\n                    }\n                    else {\n                        // console.log(\"文件下载完成，但大小未知\")\n                    }\n                }\n                else {\n                    // console.error(\"未找到下载项\")\n                }\n            });\n        }\n        if (detail.error && detail.error.current) {\n            // 下载被取消或者失败时，这里是能捕获到错误的，detail.error.current 包含错误类型：\n            // 取消 USER_CANCELED\n            // 失败 NETWORK_FAILED\n            msg = 'download_err';\n            err = detail.error.current;\n        }\n        // 返回信息\n        if (msg) {\n            chrome.tabs.sendMessage(data.tabId, { msg, data, err });\n            // 清除这个任务的数据\n            dlData[detail.id] = null;\n            chrome.storage.local.set({ dlData });\n        }\n    }\n});\n"],"names":[],"sourceRoot":""}